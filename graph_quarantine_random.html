<!DOCTYPE html>
<meta charset="utf-8">

<title>Dynamic Population / Spreader Model</title>

<table style="width:100%">
<tr>
 <td>Transmission Parameters:</td>
</tr>
<tr>
 <td>
    <label for="r0">Population Spread (R0):</label>
    <input type="range" min="0" max="3.0" id="r0" step=.01>
    <input type="number" id="r0-value">
 </td>
  <td>
    <label for="cross_infection">Cross Infection (R0):</label>
    <input type="range" min="0" max="1.0" id="cross_infection" step=.0001>
    <input type="number" id="cross_infection-value">
 </td>
 <td>
  <label for="group_skew">Heterogenity:</label>
  <input type="range" min="0" max="10.0" id="group_skew" step=.01>
  <input type="number" id="group_skew-value">
</td>
 </tr>
 <tr>
   <td>Lockdown Transmission Parameters:</td>
 </tr>
 <tr>
 <td>
    <label for="lockdown_r0">Population Spread (R0):</label>
    <input type="range" min="0" max="3.0" id="lockdown_r0" step=.01>
    <input type="number" id="lockdown_r0-value">
 </td>
  <td>
    <label for="lockdown_cross_infection">Cross Infection (R0):</label>
    <input type="range" min="0" max="1.0" id="lockdown_cross_infection" step=.0001>
    <input type="number" id="lockdown_cross_infection-value">
 </td>
</tr>
 <tr>
   <td>Lockdown Parameters:</td>
 </tr>
 <tr>
 <td>
    <label for="lockdown_start">Lockdown Start:</label>
    <input type="range" min="-1" max="100" id="lockdown_start">
    <input type="number" id="lockdown_start-value">
 </td>
 <td>
    <label for="lockdown_end">Lockdown End:</label>
    <input type="range" min="-1" max="100" id="lockdown_end">
    <input type="number" id="lockdown_end-value">
 </td>
 <td>
    <label for="quarantine_percentage">Quarantine Percentage:</label>
    <input type="range" min="0" max="100" id="quarantine_percentage">
    <input type="number" id="quarantine_percentage-value">
 </td>
  <td>
    <label for="quarantine_leave_percentage">Quarantine Leave Percentage:</label>
    <input type="range" min="0" max="100" id="quarantine_leave_percentage">
    <input type="number" id="quarantine_leave_percentage-value">
 </td>
 
</tr>
<tr>
 <td>Graph Parameters:</td>
</tr>
<tr>
 <td>
  <label for="total_infected_max">Percentage Infected Display Max:</label>
  <input type="range" min="0" max="100" id="total_infected_max" step=1>
  <input type="number" id="total_infected_max-value" size="10">
 </td>
 <td>
  <label for="infected_max">Current Infected Display Max:</label>
  <input type="range" min="0" max="100000" id="infected_max" step=1>
  <input type="number" id="infected_max-value" size="100"> 
 </td>
 <td>
  <label for="days">Simulation days:</label>
  <input type="range" min="0" max="365" id="days" step=1>
  <input type="number" id="days-value" size="100"> 
 </td> 
</tr>
<tr>
 </td>
 <td>
   <div id=lockdownPercentage></div>
 </td>
 <td>
   <a href="" id="myInput">Permalink</a>
 </td>
 <td>
    <a href="" id="graphImage" title="On chrome right click and open in new tab.">Graph Image Link</a>
</td>
</tr>


</table>

<div id="curve_chart"></div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>



function drawChart(simulation_data) {

  var data = new google.visualization.DataTable();
  data.addColumn('number', 'Day');
  data.addColumn({type: 'string', role: 'annotation'});
  data.addColumn('number', "Percent Infected");
  data.addColumn('number', "Infected Per Million");
  for (var i in simulation_data) {
    annotation = null
    if (i == params.lockdown_start) {
      annotation = 'Lockdown Start'
    } else if (i == params.lockdown_end) {
      annotation = 'Lockdown End'
    }
    simulation_point = simulation_data[i]
    data.addRow([simulation_point.day, annotation, (simulation_point.ever_sick * 100) / simulation_point.population, simulation_point.infected * 1e6 / simulation_point.population])
  }

  var options = {
    title: params.title,
    width: 900,
    height: 500,
    // Gives each series an axis that matches the vAxes number below.
    series: {
          0: {targetAxisIndex: 0},
          1: {targetAxisIndex: 1}
        },
    vAxes: {
      // Adds titles to each axis.
      0: {title: 'Percentage Infected'},
      1: {title: 'Infected Per Million'}
    },
    annotations: {
      style: 'line'
    }
  };
  if (params.total_infected_max != 0) {
    options.vAxes[0].maxValue = params.total_infected_max
  }
  if (params.infected_max != 0) {
    options.vAxes[1].maxValue = params.infected_max
  }

  var chart = new google.visualization.LineChart(document.getElementById('curve_chart'));

  chart.draw(data, options);
  return chart;
}

function paramOrDefault(w, param, default_val) {
  if (param == "title") {
    return w.get(param) || default_val
  }
  let val = parseFloat(w.get(param))
  if(val == 0) {
    return 0
  }
  return val || default_val
  
}
  
function defaultParams() {
  return {
    r0: 1.0,
    group_skew: 2.0,
    cross_infection: 0.1,
    pop: 1e5,
    groups: 1e3,
    lockdown_start: -1,
    lockdown_end: -1,
    quarantine_percentage: 1,
    quarantine_leave_percentage: .1,
    lockdown_r0: 1.0,
    lockdown_cross_infection: .1,
    infected_max: 0,
    total_infected_max: 0,
    days: 100,
    num_neighbors: 3,
    infected_days: 7,
    title: "Infections Over Time"
  } 
}

function getParams() {
  let w = new URLSearchParams(window.location.search)

  default_params = defaultParams()
  params = {}
  for (let [key, value] of Object.entries(default_params)) {
     params[key] = paramOrDefault(w, key, value)
  } 
  return params

}

params = getParams() 
function makeWindowParams() {
  original_params = defaultParams()
  parts = []
  for (let [key, value] of Object.entries(params)) {
     if (value != original_params[key]) {
      parts.push(key + "=" + value)
     }
  } 
  return parts.join("&")  
}

function copyGraphLink() {
  var copyText = document.getElementById("myInput");
  /* Select the text field */
  copyText.select();
  copyText.setSelectionRange(0, 99999); /*For mobile devices*/

  /* Copy the text inside the text field */
  document.execCommand("copy");
}

function initialInfected(num_infected, infected_days) {
  infection = []
  for (var i = 0; i < infected_days; i++) {
    infection.push(0)
  }
  infection[0] = num_infected
  return infection
}

function initialState() {
   groups = []
   total_r0 = 0.0
   expected_total = params.r0 * params.groups
   expected_lockdown_total = params.lockdown_r0 * params.groups
   initial_infected_groups = {}
   for (i=0; i < 10; i++) {
    initial_infected_groups[i] = true
   }

   for(i=0 ; i < params.groups; i++) {
    group_r0 =  Math.pow(Math.random(), params.group_skew)
    total_r0 += group_r0
    infected = 0
    if (i in initial_infected_groups) {
      infected = 100
    }
    groups.push({
      population: params.pop,
      infected: initialInfected(infected, params.infected_days),
      neighbors: {},
      ever_sick: infected,
      r0: group_r0,
      cross_infection: params.cross_infection,
      lockdown_cross_infection: params.lockdown_cross_infection,
      in_lockdown: false
    })}

    for (i=0; i < params.groups - 1; i++) {
      groups[i].neighbors[i + 1] = true
      groups[i + 1].neighbors[i] = true
    }

    for (i=0; i < (params.num_neighbors - 1) *  params.groups; i++) {
      a = getRandomInt(0, params.groups)
      dist = getRandomInt(0, 50)
      b = (a + dist) % params.groups
      groups[a].neighbors[b] = true 
      groups[b].neighbors[a] = true
    }

    for (group_index in groups) {
      r0 = groups[group_index].r0
      groups[group_index].r0 = r0 * (expected_total / total_r0)
      groups[group_index].lockdown_r0 = r0 * (expected_lockdown_total / total_r0)
    }

   return groups


}

function poisson(mean) {
  var L = Math.exp(-mean);
  var p = 1.0;
  var k = 0;

  do {
      k++;
      p *= Math.random();
  } while (p > L);

  return k - 1;
}

function expectedNewInfections(state, new_infections) {
  if(state.population == 0 || new_infections == 0) {
    return 0;
  }
  actual_infections = poisson(new_infections)

  prob_single_not = 1 - (1 / state.population)
  prob_total_not = Math.pow(prob_single_not, actual_infections)
  prob_selected = 1 - prob_total_not
  return Math.round((state.population - state.ever_sick) * prob_selected) 
}

function groupR0(group, day, group_index) {
  lockdown_started = day >= params.lockdown_start && params.lockdown_start != -1
  lockdown_ended = day > params.lockdown_end && params.lockdown_end != -1
  in_lockdown = lockdown_started && !lockdown_ended
  if (in_lockdown) {
    percentage_infected = AllInfected(group.infected) / group.population * 100
    if (percentage_infected > params.quarantine_percentage || (group.in_quarantine && percentage_infected > params.quarantine_leave_percentage)) {
      return {
        current_r0: group.lockdown_r0,
        cross_infection: 0,
        in_quarantine: true
      }
    }

    return {
      current_r0: group.lockdown_r0,
      cross_infection: group.lockdown_cross_infection,
      in_quarantine: false
    }
  } else {
    return {
      current_r0: group.r0,
      cross_infection: group.cross_infection,
      in_quarantine: false
    }
  }
}

function AddInfections(existing_infections, new_infections) {
  added_infections = []
  added_infections.push(new_infections)
  for (var i = 0; i < existing_infections.length - 1; i++) {
    added_infections.push(existing_infections[i])
  }
  return added_infections
}

function AllInfected(group_infections) {
  total_infected = 0
  for (var i in group_infections) {
    total_infected += group_infections[i]
  }
  return total_infected
}

function advanceState(current_groups, day) {
   new_groups = []
   global_infections_by_group = []
   in_quarantine = []
   for (i = 0; i < current_groups.length; i++) {
    global_infections_by_group.push(0)
    in_quarantine.push(false)
   }
   for (i = 0; i < current_groups.length; i++) {
    group_params = groupR0(current_groups[i], day, i)
    in_quarantine[i] = group_params.in_quarantine
    current_infected = AllInfected(current_groups[i].infected)
    group_global_infections = current_infected * group_params.current_r0 * group_params.cross_infection / params.infected_days

    neighbor_infections = group_global_infections / params.num_neighbors
    for (var neighbor_index in current_groups[i].neighbors) {
      global_infections_by_group[neighbor_index] += neighbor_infections
     }
   }

   for (i = 0; i < current_groups.length; i++) {
    group = current_groups[i]
    group_params = groupR0(group, day, i)

    group_infections = AllInfected(current_groups[i].infected) * group_params.current_r0 * (1.0 - group_params.cross_infection) /  params.infected_days
    group_global_infections = global_infections_by_group[i]
    
    actual_infections = expectedNewInfections(group, group_infections + group_global_infections)
    new_groups.push({
      population: group.population,
      neighbors: group.neighbors,
      infected: AddInfections(group.infected, actual_infections),
      ever_sick: group.ever_sick + actual_infections,
      r0: group.r0,
      lockdown_r0: group.lockdown_r0,
      cross_infection: group.cross_infection,
      lockdown_cross_infection: group.lockdown_cross_infection,
      in_quarantine: in_quarantine[i]
    })
   }
   return new_groups
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
}


function getTotalParams(current_groups, day) {
  total_infected = 0
  total_population = 0
  total_sick = 0
  total_lockdown = 0
  for (i = 0; i < current_groups.length; i++) {
    total_infected += current_groups[i].ever_sick
    total_population += current_groups[i].population
    total_sick += current_groups[i].infected[0]
    total_lockdown += current_groups[i].in_quarantine ? 1 : 0
  }
  return {
    day: day,
    ever_sick: total_infected,
    population: total_population,
    infected: total_sick,
    total_lockdown: total_lockdown,
  }
}


function updateGraph() {
  groups = initialState();
  data = []
  data.push(getTotalParams(groups, 0))
  all_groups = [groups]
  for(day = 1; day <= params.days; day++) {
    groups = advanceState(groups, day);
    all_groups.push(groups)
    data.push(getTotalParams(groups, day));
  }

  chart = drawChart(data);
  var copyText = document.getElementById("myInput");
  copyText.href =  window.location.href.split('?')[0] + "?" + makeWindowParams()
  var graphLink = document.getElementById("graphImage");
  graphLink.href = chart.getImageURI()
  var lockdownPercentage = document.getElementById("lockdownPercentage");
  total_groups_days = groups.length * params.days
  total_quarantine_days = 0
  for (var data_index in data) {
    total_quarantine_days += data[data_index].total_lockdown
  }
  percentage = (total_quarantine_days * 100 / total_groups_days).toFixed(2)


  lockdownPercentage.innerText =   "Percentage of time in quarantine: " + percentage + "%"
}

function updateAttribute(attribute, value, update_graph=true) {
  // adjust the text on the range slider
  d3.select("#" + attribute + "-value").text(value);
  d3.select("#" + attribute + "-value").property("value", value);
  d3.select("#" + attribute).property("value", value);
  if(update_graph == true) {
     updateGraph();
  }
}

function initializeGraph() {
  for (let [key, value] of Object.entries(params)) {
    d3.select("#" + key).on("input", function() {
      params[key] = +this.value;
      updateAttribute(key, +this.value);
    });

    d3.select("#" + key + "-value").on("input", function() {
      params[key] = +this.value;
      updateAttribute(key, +this.value);
    });
    updateAttribute(key, value, false)
  }
  updateAttribute("r0", params.r0)
}
google.charts.load('current', {packages: ['corechart', 'line']}).then(initializeGraph);
</script>
