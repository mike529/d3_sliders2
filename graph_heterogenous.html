<!DOCTYPE html>
<meta charset="utf-8">

<title>Dynamic Population / Spreader Model</title>


<table style="width:100%">
<tr>
 <td>Transmission Parameters:</td>
</tr>
<tr>
 <td>
    <label for="r0">Population Spread (R0):</label>
    <input type="range" min="0" max="3.0" id="r0" step=.01>
    <input type="number" id="r0-value">
 </td>
  <td>
    <label for="group_skew">Group Skew (Alpha):</label>
    <input type="range" min="1.01" max="10.0" id="group_skew" step=.01>
    <input type="number" id="group_skew-value">
 </td>
  <td>
    <label for="cross_infection">Cross Infection (R0):</label>
    <input type="range" min="0" max="1.0" id="cross_infection" step=.0001>
    <input type="number" id="cross_infection-value">
 </td>
 <td>
    <label for="lockdown_start">Lockdown Start:</label>
    <input type="range" min="0" max="101" id="lockdown_start">
    <input type="number" id="lockdown_start-value">
 </td>
 <td>
    <label for="lockdown_end">Lockdown End:</label>
    <input type="range" min="0" max="100" id="lockdown_end">
    <input type="number" id="lockdown_end-value">
 </td>
 <td>
    <label for="lockdown_factor">Lockdown Factor:</label>
    <input type="range" min="1.0" max="10.0" id="lockdown_factor" step=.01>
    <input type="number" id="lockdown_factor-value">
 </td> 
</tr>
<tr>
 <td>Population Parameters:</td>
</tr>
<tr>
 <td>
  <label for="pop">Group Size:</label>
  <input type="range" min="10000" max="10000000" id="pop" step=10000>
  <input type="number" id="pop-value" size="10">
 </td>
 <td>
  <label for="groups">Number Groups:</label>
  <input type="range" min="0" max="10000" id="groups" step=1>
  <input type="number" id="groups-value" size="100"> 
 </td>
</tr>
<tr>
 </td>
 <td>
   <a href="" id="myInput">Permalink</a>
 </td>
</tr>


</table>

<div id="curve_chart"></div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>



function drawChart(simulation_data) {

  var data = new google.visualization.DataTable();
  data.addColumn('number', 'Day');
  data.addColumn('number', "Percent Infected");
  data.addColumn('number', "Infected Per Million");
  for (var i in simulation_data) {
    simulation_point = simulation_data[i]
    data.addRow([simulation_point.day, (simulation_point.ever_sick * 100) / simulation_point.population, simulation_point.infected * 1e6 / simulation_point.population])
  }

  var options = {
    chart: {
      title: 'Infections over time'
    },
    width: 900,
    height: 500,
    series: {
      // Gives each series an axis name that matches the Y-axis below.
      0: {axis: 'Percentage Ever Infected'},
      1: {axis: 'Infected Per Million'}
    },
    axes: {
      // Adds labels to each axis; they don't have to match the axis names.
      y: {
        TotalInfected: {label: 'Percentage Infected'},
        NewInfected: {label: 'Infected Per Million',}
      }
    }
  };


  var chart = new google.charts.Line(document.getElementById('curve_chart'));

  chart.draw(data, options);
}

function paramOrDefault(w, param, default_val) {
  let val = parseFloat(w.get(param))
  if(val == 0) {
    return 0
  }
  return val || default_val
  
}
  
function getParams() {
  let w = new URLSearchParams(window.location.search)

  return {
    r0: paramOrDefault(w, "r0", 1.0),
    group_skew: paramOrDefault(w, "group_skew", 2.0),
    cross_infection: paramOrDefault(w, "cross_infection", 0.1),
    pop: paramOrDefault(w, "pop", 50000),
    groups: paramOrDefault(w, "groups", 2000),
    lockdown_start: paramOrDefault(w, "lockdown_start", 101),
    lockdown_end: paramOrDefault(w, "lockdown_end", 101),
    lockdown_factor: paramOrDefault(w, "lockdown_factor", 2)
  }
}

params = getParams() 

function makeWindowParams() {
  parts = []
  for (let [key, value] of Object.entries(params)) {
     parts.push(key + "=" + value)
  } 
  return parts.join("&")  
}

function copyGraphLink() {
  var copyText = document.getElementById("myInput");
  /* Select the text field */
  copyText.select();
  copyText.setSelectionRange(0, 99999); /*For mobile devices*/

  /* Copy the text inside the text field */
  document.execCommand("copy");
}

function paretoDistribution (alpha, uniform_random) {
    var u = 1.0 - uniform_random
    var unscaled = 1.0 / Math.pow(u, 1.0 / alpha);
    return (alpha - 1) * unscaled / alpha
}

function initialState() {
   groups = []
   total_r0 = 0.0
   expected_total = params.r0 * params.groups
   for(i=0 ; i < params.groups; i++) {
    group_r0 = paretoDistribution(params.group_skew, (i + .5) / params.groups)
    total_r0 += group_r0
    infected = 1 / params.groups
    groups.push({
      population: params.pop,
      infected: infected,
      ever_sick: infected,
      r0: group_r0
    })}

    for (group_index in groups) {
      groups[group_index].r0 = groups[group_index].r0 * (expected_total / total_r0)
    }

   return groups


}

function expectedNewInfections(state, new_infections) {
  if(state.population == 0) {
    return 0;
  }
  prob_single_not = 1 - (1 / state.population)
  prob_total_not = Math.pow(prob_single_not, new_infections)
  prob_selected = 1 - prob_total_not
  return (state.population - state.ever_sick) * prob_selected 
}

function groupR0(group, day) {
  in_lockdown = day >= params.lockdown_start && day <= params.lockdown_end
  current_r0 = group.r0
  if (in_lockdown) {
    current_r0 /= params.lockdown_factor
  }
  return current_r0
}

function advanceState(current_groups, day) {
   new_groups = []
   global_infections = 0
   total_population = 0
   for (i = 0; i < current_groups.length; i++) {
    total_population += current_groups[i].population
    global_infections += current_groups[i].infected * groupR0(current_groups[i], day) * params.cross_infection
   }

   for (i = 0; i < current_groups.length; i++) {
    group = current_groups[i]
    group_infections = group.infected * groupR0(group, day) * (1.0 - params.cross_infection)
    group_global_infections = global_infections * group.population / total_population
    actual_infections = expectedNewInfections(group, group_infections + group_global_infections)
    new_groups.push({
      population: group.population,
      infected: actual_infections,
      ever_sick: group.ever_sick + actual_infections,
      r0: group.r0
    })
   }
   return new_groups
}

function getTotalParams(current_groups, day) {
  total_infected = 0
  total_population = 0
  total_sick = 0
  for (i = 0; i < current_groups.length; i++) {
    total_infected += current_groups[i].ever_sick
    total_population += current_groups[i].population
    total_sick += current_groups[i].infected
  }
  return {
    day: day,
    ever_sick: total_infected,
    population: total_population,
    infected: total_sick
  }
}

function AddR0Stats(data) {
  prev_sick = data[0].infected
  for (var data_index in data) {
    new_sick = data[data_index].infected
    percent_infected = data[data_index].ever_sick / data[data_index].population
    data[data_index].rt = new_sick / prev_sick
    data[data_index].r0 = (new_sick / prev_sick) / (1 - percent_infected)
    prev_sick = new_sick
  }
}

function drawGraph(data){

  function y_func(d) {
    return d.ever_sick * 100 / d.population
  }

  // set the dimensions and margins of the graph
  var margin = {top: 20, right: 20, bottom: 30, left: 50},
      width = 960 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

  // set the ranges
  var x = d3.scaleLinear().range([0, width]);
  var y = d3.scaleLinear().range([height, 0]);

  // define the line
  var valueline = d3.line()
      .x(function(d) { return x(d.day); })
      .y(function(d) { return y(y_func(d)); });

  // append the svg obgect to the body of the page
  // appends a 'group' element to 'svg'
  // moves the 'group' element to the top left margin
  d3.select("body").select("svg").remove();
  var svg = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

  // Scale the range of the data
  x.domain([0, d3.max(data, function(d) { return d.day; })]);
  if (params.ymax == 0) {
     y.domain([0, d3.max(data, function(d) { return y_func(d) })]);
  } else {
    y.domain([0, params.ymax])
  }
  
  // Add the valueline path.
  svg.append("path")
      .data([data])
      .attr("class", "line")
      .attr("d", valueline);

  // Add the X Axis
  svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  // Add the Y Axis
  svg.append("g")
      .call(d3.axisLeft(y));
  
  // text label for the y axis
  svg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x",0 - (height / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Percentage Infected");     
}



function updateGraph() {
  groups = initialState();
  data = []
  data.push(getTotalParams(groups, 0))
  for(day = 1; day <= 100; day++) {
    groups = advanceState(groups, day);
    data.push(getTotalParams(groups, day));
  }

  AddR0Stats(data)

  drawChart(data);
  var copyText = document.getElementById("myInput");
  copyText.href =  window.location.href.split('?')[0] + "?" + makeWindowParams()
}

function updateAttribute(attribute, value, update_graph=true) {
  // adjust the text on the range slider
  d3.select("#" + attribute + "-value").text(value);
  d3.select("#" + attribute + "-value").property("value", value);
  d3.select("#" + attribute).property("value", value);
  if(update_graph == true) {
     updateGraph();
  }
}

function initializeGraph() {
  for (let [key, value] of Object.entries(params)) {
    d3.select("#" + key).on("input", function() {
      params[key] = +this.value;
      updateAttribute(key, +this.value);
    });

    d3.select("#" + key + "-value").on("input", function() {
      params[key] = +this.value;
      updateAttribute(key, +this.value);
    });
    updateAttribute(key, value, false)
  }
  updateAttribute("r0", params.r0)
}
google.charts.load('current', {packages: ['corechart', 'line']}).then(initializeGraph);
</script>
