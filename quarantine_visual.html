<!DOCTYPE html>
<meta charset="utf-8">

<title>Dynamic Population / Spreader Model</title>
<h1> Global Parameters </h1>
<table style="width:100%">
<tr>
 <td>
    <label for="pop">Group Size:</label>
    <input type="number" id="pop"  title="Number of people in each cell." oninput="updateAndInitializeFromParams('pop', +this.value, false)">
 </td>
 <td>
  <label for="group_skew">Heterogenity:</label>
  <input type="number" id="group_skew"  title="Variability of R0: 0=Each group has the same R0." oninput="updateAndInitializeFromParams('group_skew', +this.value, false)">
 </td> 
</tr>
<tr>
<td>
  <label for="title">Select State:</label>
  <select id="title" title="Which state's parameters to edit." onchange="updateAndInitializeFromParams('title', this.options[this.selectedIndex].value, false)">  
</td>
<td>
  <button onclick="deleteState()" title="Delete the current state.">Delete State</button>
  <button onclick="addState()" title="Adds a new state, it starts with the same parameters as the current one.">Add State</button>
</td>
</tr>
</table>
<h1>State Parameters</h1>
<table style="width:100%">
<tr>
 <td>
    <label for="r0">Population Spread (R0):</label>
    <input type="number" id="r0" oninput="updateAndInitializeFromParams('r0', +this.value, true)" title="The average R0.">
 </td>
<td>
    <label for="neighbor_infections">Neighbor Interactions Per Million</label>
    <input type="number" id="neighbor_infections" oninput="updateAndInitializeFromParams('neighbor_infections', +this.value, true)" title="The proportion of interactions with neighboring cells.">
 </td>
 <td>
    <label for="global_infections">Global Interactions Per Million</label>
    <input type="number" id="global_infections" oninput="updateAndInitializeFromParams('global_infections', +this.value, true)" title="The proportion of interactions with a random cell.">
 </td>
</tr>
<tr>
 <td>
    <label for="quarantine_percentage">Quarantine Percentage:</label>
    <input type="number" id="quarantine_percentage" oninput="updateAndInitializeFromParams('quarantine_percentage', +this.value, true)" title="At what percentage of currently infected people does a cell enter quarantine. Quarantine means that no other cells interact with it.">
 </td>

 <td>
    <label for="quarantine_leave_percentage">Quarantine Leave Percentage:</label>
    <input type="number" id="quarantine_leave_percentage" oninput="updateAndInitializeFromParams('quarantine_leave_percentage', +this.value, true)"  title="If a cell is in quarantine, at what percentage of currently infected people can it leave quarantine and restart neighbor interactions.">
 </td>
   <td>
    <label for="quarantine_neighbors">Quarantine Neighbors:</label>
    <input type="checkbox" id="quarantine_neighbors" oninput="updateAndInitializeFromParams('quarantine_neighbors', this.checked, true)" title="If a celll is in quarantine, do we also quarantine neighbors of the cell.">
 </td> 
</tr>
</table>
<h1> Animation Transitions </h1>
<div id="transitions"></div>

<table style="width:100%">
<tr>
  <td>
    <button onclick="resetSimulation()">Restart</button>
    <button onclick="resetRandom()">New Random Seed</button>
    <button onclick="startAnimation()">Start/Stop Animation</button>    
    <button onclick="downloadGIF()">Download GIF</button>   
    <label for="autoplay">Autoplay:</label>
    <input type="checkbox" id="autoplay" oninput="updateAndInitializeFromParams('autoplay', this.checked, false)">
    <a href="" id="myInput" title="A shareable link with all of the settings intact.">Permalink</a>
    <td>
      <label for="animation_speed">Animation Speed (Days / s):</label>
      <input type="number" id="animation_speed"  oninput="updateAndInitializeFromParams('animation_speed', +this.value, false)">
    </td> 
  </td>
</tr>
</table>

<div class="container" style="display: flex">;
  <canvas id="myCanvas" width="750" height="600" style="border:1px solid #d3d3d3;"></canvas>
  <div id="curve_chart" style="flex-grow: 1;"></div>
</div>



<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="whammy.js"></script>
<script>


function seeded_random(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}


ROW_WIDTH = 75
GRAPH_OFFSET = 100
GROUPS = 3750


function getNeighbors(index, num_groups) {
  var x = index % ROW_WIDTH
  var y = Math.floor(index  / ROW_WIDTH)
  var num_rows = num_groups / ROW_WIDTH
  neighbors = []
  for (var i = -1; i <= 1; i++) {
    for (var j = -1; j <= 1; j++) {
      if (i != 0 || j != 0) {
        neighbor_x = (x + i) 
        neighbor_y = (y + j)
        if (neighbor_x >= 0 && neighbor_x < ROW_WIDTH && neighbor_y >= 0 && neighbor_y < num_rows) {
          neighbors.push(neighbor_y * ROW_WIDTH + neighbor_x)
        }
      }
    } 
  }
  return neighbors
}

function getTotalParams(current_groups, day, state) {
  var total_infected = 0
  var total_population = 0
  var total_sick = 0
  for (i = 0; i < current_groups.length; i++) {
    total_infected += current_groups[i].ever_sick
    total_population += current_groups[i].population
    total_sick += AllInfected(current_groups[i].infected)
  }
  return {
    day: day,
    state: state,
    ever_sick: total_infected,
    population: total_population,
    infected: total_sick
  }
}

function drawChart(simulation_data) {

  var data = new google.visualization.DataTable();
  data.addColumn('number', 'Day');
  data.addColumn({type: 'string', role: 'annotation'});
  data.addColumn('number', "Percent Infected");
  data.addColumn('number', "Infected Per Million");
  prev_state = null
  for (var i in simulation_data) {
    annotation = null
    simulation_point = simulation_data[i]
    if (prev_state != null && simulation_point.state != prev_state) {
      annotation = simulation_point.state
    }
    prev_state = simulation_point.state
    data.addRow([simulation_point.day, annotation, (simulation_point.ever_sick * 100) / simulation_point.population, simulation_point.infected * 1e6 / simulation_point.population])
  }

  var options = {
    title: params.title,
    width: 900,
    height: 500,
    // Gives each series an axis that matches the vAxes number below.
    series: {
          0: {targetAxisIndex: 0},
          1: {targetAxisIndex: 1}
        },
    vAxes: {
      // Adds titles to each axis.
      0: {title: 'Percentage Infected'},
      1: {title: 'Infected Per Million'}
    },
    annotations: {
      style: 'line'
    }
  };
  if (params.total_infected_max != 0) {
    options.vAxes[0].maxValue = params.total_infected_max
  }
  if (params.infected_max != 0) {
    options.vAxes[1].maxValue = params.infected_max
  }

  var chart = new google.visualization.LineChart(document.getElementById('curve_chart'));

  chart.draw(data, options);
  return chart;
}

function drawCanvas(data, day, day_params) {
  var c = document.getElementById("myCanvas");
  var ctx = c.getContext("2d");
  var rect_height = 10
  var rect_width = 10
  ctx.clearRect(0, 0, c.width, c.height);
  ctx.fillStyle = '#FFFFFF'
  ctx.fillRect(0,0, c.width, c.height)


  infected = 0
  ever_sick = 0
  population = 0
  groups_with_infection = 0
  quarantined_groups = 0
  for (group_index in data) {
    var group = data[group_index]
    infected += AllInfected(group.infected)
    population += group.population
    ever_sick += group.ever_sick
    if (infected > 0) {
      groups_with_infection += 1
    }
    if (group.in_quarantine) {
      quarantined_groups += 1
    }
  }

  ctx.fillStyle = '#000000'
  ctx.font = '15px serif';


  ctx.fillText('State: ' + day_params.title, 0, 15)
  ctx.fillText('Day: ' + day, 0, 30)
  ctx.fillText('Currently Infected per Million: ' + (infected * 1e6 / population).toFixed(0), 0, 45);
  ctx.fillText('Percentage Ever Infected: ' + (ever_sick * 100 / population).toFixed(2) + '%', 0, 60)
  ctx.fillText('Percentage in quarantine: ' + (quarantined_groups * 100 / data.length).toFixed(2) + '%', 0, 75)

  for (group_index in data) {

    var x = group_index % ROW_WIDTH
    var y = Math.floor(group_index  / ROW_WIDTH)
    var group = data[group_index]
    fraction_ever_infected = Math.sqrt(group.ever_sick / group.population) * 256
    ctx.fillStyle = `rgb(
      ${fraction_ever_infected},
      ${255 - fraction_ever_infected}, 
      0)`;
    rect_left = x * rect_width
    rect_top =  y * rect_height + GRAPH_OFFSET

    ctx.fillRect(rect_left, rect_top, rect_width, rect_height);
    ctx.beginPath();
    ctx.rect(rect_left, rect_top, rect_width, rect_height);
    ctx.stroke();
    if (data[group_index].in_quarantine) {
      ctx.strokeStyle = '#000000'
      ctx.beginPath();
      ctx.moveTo(rect_left, rect_top);
      ctx.lineTo(rect_left + rect_width, rect_top + rect_height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(rect_left + rect_width, rect_top);
      ctx.lineTo(rect_left, rect_top + rect_height);
      ctx.stroke();
    }
  }
  encoder.add(c)
}


function defaultInitialState() {
  return  {
      'r0': 2,
      'neighbor_infections': 9000,
      'global_infections': 1000,
      'quarantine_percentage': 100,
      'quarantine_leave_percentage': .1,
      'quarantine_neighbors': false
    }
}


function defaultParams() {
  return  {
    'pop': 1e5,
    'group_skew': 2,
    'infected_days': 7,
    'title': 'Initial',
    'animation_speed': 5,
    'autoplay': false,
    'random_seed': new Date().getTime(),
    'state_params': {
      'Initial': defaultInitialState(),
      'Lockdown': {
        'r0': .5,
        'neighbor_infections': 9000,
        'global_infections': 1000,
        'quarantine_percentage': 100,
        'quarantine_leave_percentage': .1,
        'quarantine_neighbors': false
      }
    },
    'transitions': [
      {'state_name': 'Initial', 'end_day': 365},
    ]
  }
}




function resetRand() {
  seededRandom = seeded_random(params.random_seed)
}




function initialInfected(num_infected, infected_days) {
  infection = []
  for (var i = 0; i < infected_days; i++) {
    infection.push(0)
  }
  infection[0] = num_infected
  return infection
}

function initialState(current_params) {
   groups = []
   total_r0 = 0.0
   expected_total = GROUPS
   initial_infected_groups = {}
   for (i=0; i < 10; i++) {
    initial_infected_groups[getRandomInt(0, GROUPS)] = true
   }

   for(i=0 ; i < GROUPS; i++) {
    group_r0 =  Math.pow(seededRandom(), current_params.group_skew)
    total_r0 += group_r0
    infected = 0
    if (i in initial_infected_groups) {
      infected = 100
    }
    groups.push({
      population: current_params.pop,
      infected: initialInfected(infected, current_params.infected_days),
      neighbors: {},
      ever_sick: infected,
      r0: group_r0,
      in_quarantine: false
    })}

    for (i=0; i < GROUPS; i++) {
      neighbors = getNeighbors(i, GROUPS)
      for (neighbor_index in neighbors)  {
        groups[i].neighbors[neighbors[neighbor_index]] = true
      }
    }

    for (group_index in groups) {
      r0 = groups[group_index].r0
      groups[group_index].r0 = r0 * (expected_total / total_r0)
    }

   return groups
}

function poisson(mean) {
  var k = 0
  while (mean > 2048) {
    k += mean / 2
    mean /= 2
  }
  var L = -mean;
  var p = 0.0;
  
  do {
      k++;
      p += Math.log(seededRandom());
  } while (p > L);

  return k - 1;
}

function expectedNewInfections(state, new_infections) {
  if(state.population == 0 || new_infections == 0) {
    return 0;
  }
  actual_infections = poisson(new_infections)

  prob_single_not = 1 - (1 / state.population)
  prob_total_not = Math.pow(prob_single_not, actual_infections)
  prob_selected = 1 - prob_total_not
  return Math.round((state.population - state.ever_sick) * prob_selected) 
}

function AddInfections(existing_infections, new_infections) {
  added_infections = []
  added_infections.push(new_infections)
  for (var i = 0; i < existing_infections.length - 1; i++) {
    added_infections.push(existing_infections[i])
  }
  return added_infections
}

function AllInfected(group_infections) {
  total_infected = 0
  for (var i in group_infections) {
    total_infected += group_infections[i]
  }
  return total_infected
}

function inQuarantine(group, current_params) {
  percentage_infected = AllInfected(group.infected) * 100 / group.population
  return percentage_infected >= current_params.quarantine_percentage || (group.in_quarantine && percentage_infected >= current_params.quarantine_leave_percentage)
}

function advanceState(current_groups, day, current_params) {
   new_groups = []
   infections_by_group = []
   global_infections = 0
   in_quarantine = []
   num_not_in_quarantine = 0

   for (i = 0; i < current_groups.length; i++) {
    in_quarantine.push(false)
    infections_by_group.push(0)
   }

   for (i = 0; i < current_groups.length; i++) {
    var current_group = current_groups[i]
    group_in_quarantine = inQuarantine(current_group, current_params)
    if (group_in_quarantine) {
      in_quarantine[i] = true
      if (current_params.quarantine_neighbors) {
        for (var neighbor in current_group.neighbors) {
          in_quarantine[neighbor] = true
        }
      }
    }
   }

   for (i = 0; i < current_groups.length; i++) {
    current_infected = AllInfected(current_groups[i].infected)
    if (in_quarantine[i]) {
      fraction_global = 0
      fraction_neighbor = 0
    } else {
      fraction_global = current_params.global_infections / 1e6
      fraction_neighbor = current_params.neighbor_infections / 1e6
      num_not_in_quarantine += 1
    }
    fraction_local = 1 - (fraction_neighbor + fraction_global)
    new_infections = current_infected * current_groups[i].r0 * current_params.r0 / current_params.infected_days
    global_infections += new_infections * fraction_global
    infections_by_group[i] += new_infections * fraction_local
    non_quarantine_neighbors = []
    for (neighbor in current_groups[i].neighbors) {
      if (!in_quarantine[neighbor]) {
        non_quarantine_neighbors.push(neighbor)
      }
    }
    for (neighbor_index in non_quarantine_neighbors) {
      infections_by_group[non_quarantine_neighbors[neighbor_index]] += (new_infections * fraction_neighbor) / non_quarantine_neighbors.length
    }
   }

   for (i = 0; i < current_groups.length; i++) {
      var group = current_groups[i]
      group_global_infections = 0
      if (!in_quarantine[i]) {
        group_global_infections = global_infections / (num_not_in_quarantine)
      }
      actual_infections = expectedNewInfections(group, group_global_infections + infections_by_group[i])
      new_groups.push({
        population: group.population,
        neighbors: group.neighbors,
        infected: AddInfections(group.infected, actual_infections),
        ever_sick: group.ever_sick + actual_infections,
        r0: group.r0,
        in_quarantine: in_quarantine[i]
      })
   }
   return new_groups
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(seededRandom() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
}


timeout_id = null

var encoder = new Whammy.Video(15); 

function handleDataAvailable(event) {
  if (event.data.size > 0) {
    recordedChunks.push(event.data);
  }
}


function stopAnimation() {
  if (timeout_id != null) {
    window.clearInterval(timeout_id)
    timeout_id = null    
    drawChart(daily_data)
  }
}

function startAnimation() {
  if (timeout_id == null) {
    timeout_id = window.setInterval(advanceDayInternal, 1000 / params.animation_speed)
  } else {
    stopAnimation()
  }
}

function getDailyParamState(current_day) {
  for (var transition_idx in params.transitions) {
    transition = params.transitions[transition_idx]
    if (transition.end_day >= current_day) {
      return transition.state_name
    }
  }
  return null
}

function getFullParams(transition_state) {
  new_params = {}
  for (key in params) {
    if (key == 'state_params') {
      used_state = params.state_params[transition_state]
      for (var state_key in used_state) {
        new_params[state_key] = used_state[state_key]
      }
    } else if (key != 'transitions') {
      new_params[key] = params[key]
    }
  }
  new_params['title'] = transition_state
  return new_params
}

function getParamsForDay() {
  var transition_state = getDailyParamState(day)
  if (transition_state == null) {
    return null
  }
  return getFullParams(transition_state)


}

function resetSimulation() {
  resetRand()
  stopAnimation()
  encoder = new Whammy.Video(params.animation_speed)
  day = 1
  var day_params = getParamsForDay()
  daily_data = []
  if (day_params == null) {
    groups = []
  } else {
    groups = initialState(params)  
    daily_data.push(getTotalParams(groups, day, day_params.title))
  }  
  drawCanvas(groups, day, day_params)
}

function advanceDay() {
  stopAnimation()
  advanceDayInternal()
}



function advanceDayInternal() {
  var current_params = getParamsForDay()
  if (current_params == null) {
    stopAnimation()
    return
  }

  if (day == 1) {
    resetRand()
    groups = initialState(current_params)
    drawChart(daily_data)
  }
  groups = advanceState(groups, day, current_params)
  daily_data.push(getTotalParams(groups, day, current_params.title))
  drawCanvas(groups, day, current_params)
  if (day % 10 == 0) {
    drawChart(daily_data)
  }
  day += 1
}

function resetRandom() {
  params.random_seed = new Date().getTime()
  resetRand()
}

function downloadGIF() {
  stopAnimation()
  encoder.compile(false, function(output){
    url = URL.createObjectURL(output)
    window.open(url)}
  ) 
}


function setValue(name, value, is_checkbox) {
  if (is_checkbox) {
    d3.select("#" + name).property('checked', value);
  } else {
    d3.select("#" + name).text(value);
      d3.select("#" + name).property("value", value);
  }
}

function updateAndInitializeFromParams(attr, value, is_state_param) {
  if (is_state_param) {
    params.state_params[params.title][attr] = value
  } else {
    params[attr] = value
  }
  initializeFromParams();
}

function makeSelect(element_id, options, selected_value) {
  var title_object = document.getElementById(element_id)
  var option_select_str = ""
  var found_index = -1
  var param_index = 0
  for (option_index in options) {
    var option = options[option_index]
    if (option == selected_value) {
      found_index = param_index
    }
    param_index++;
    option_select_str += `<option value="${option}">${option}</option>`
  }
  title_object.innerHTML = option_select_str;
  title_object.options.selectedIndex = found_index;
}

function deleteState() {
  var old_title = params.title
  delete params.state_params[params.title]
  remaining_keys = Object.keys(params.state_params)
  if (remaining_keys.length == 0) {
    params.state_params["Initial"] = defaultInitialState()
    remaining_keys = Object.keys(params.state_params)
  } 
  params.title = remaining_keys[0]
  new_transitions = []
  for (idx in params.transitions) {
    transition = params.transitions[idx]
    if (transition.state_name != old_title) {
      new_transitions.push(transition)
    }
  }
  params.transitions = new_transitions
  initializeFromParams()
}

function addState() {
  var new_state = prompt("Enter new state name")
  if (new_state != null) {
    new_params = {}
    Object.assign(new_params, params.state_params[params.title])

    params.state_params[new_state] = new_params
    params.title = new_state
  }
  initializeFromParams()
}

function makeTransitionSelect(selected_state, index) {
  select_label = "<label for='transition_title'>State Name:</label>"
  options = ""
  var states = Object.keys(params.state_params)
  selected_index = -1
  for (var idx in states) {
    option = states[idx]
    state = states[idx]
    if (state == selected_state) {
      options +=  `<option value="${option}" selected>${option}</option>`
    } else {
      options +=  `<option value="${option}">${option}</option>`
    }
  }
  return `<label>State Name:</label><select onchange="updateTransition('state_name', this.options[this.selectedIndex].value, ${index})">${options}</select>`
}

function deleteTransition(index) {
  params.transitions.splice(index, 1)
  initializeFromParams()
}

function addTransition(index) {
  last_transition = {}
  Object.assign(last_transition, params.transitions[params.transitions.length - 1])
  params.transitions.push(last_transition)
  initializeFromParams()
}

function updateTransition(attr_type, value, index) {
  params.transitions[index][attr_type] = value
  initializeFromParams(false)
}

function makeTransitions() {
  transition_str = ""
  for (var idx in params.transitions) {
    transition = params.transitions[idx] 
    end_day = transition.end_day
    select_str = makeTransitionSelect(transition.state_name, idx)
    input_str = `<label>End Day</label><input type="number" oninput="updateTransition('end_day', +this.value, ${idx})" text=${end_day} value=${end_day}>`
    button_str = `<button onclick="deleteTransition(${idx})">Remove Transition</button>` 
    transition_str += `<p>${select_str} ${input_str} ${button_str}</p>`
  }
  transition_str += `<p><button onclick="addTransition()">Add Transition</button></p>`
  elem = document.getElementById("transitions").innerHTML = transition_str

}

function encodeParams() {
  return btoa(JSON.stringify(params))
}

function getParamsFromWindow() {
  let w = new URLSearchParams(window.location.search)
  param_string = w.get('params')
  if (param_string == null) {
    return defaultParams()
  }
  return JSON.parse(atob(param_string))
}

params = getParamsFromWindow()

resetRand()
groups = []
daily_data = []
day = 1


function initializeFromParams(make_transitions = true) {
  setValue("pop", params.pop, false);
  setValue("group_skew", params.group_skew, false);
  makeSelect("title", Object.keys(params.state_params), params.title)
  setValue("animation_speed", params.animation_speed, false)
  setValue("autoplay", params.autoplay, true)

  state_params = params.state_params[params.title]

  setValue("r0", state_params.r0, false)
  setValue("neighbor_infections", state_params.neighbor_infections, false)
  setValue("global_infections", state_params.global_infections, false)
  setValue("quarantine_percentage", state_params.quarantine_percentage, false)
  setValue("quarantine_leave_percentage", state_params.quarantine_leave_percentage, false)
  setValue("quarantine_neighbors", state_params.quarantine_neighbors, true) 
  if (make_transitions) {
    makeTransitions()  
  }
  var copyText = document.getElementById("myInput");
  copyText.href =  window.location.href.split('?')[0] + "?params=" + encodeParams() 
}

function initializeGraph() {
  initializeFromParams()
  resetSimulation()
}

function start() {
  initializeGraph()
  drawChart(daily_data)
  if (params.autoplay) {
    startAnimation()
  }  
}

google.charts.load('current', {packages: ['corechart', 'line']}).then(start);


</script>
