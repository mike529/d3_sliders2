<!DOCTYPE html>
<meta charset="utf-8">

<title>Dynamic Population / Spreader Model</title>

<table style="width:100%">
<tr>
 <td>
    <label for="r0">Population Spread (R0):</label>
    <input type="range" min="0" max="3.0" id="r0" step=.01>
    <input type="number" id="r0-value">
 </td>
<td>
    <label for="neighbor_infections">Neighbor Interactions Per Million</label>
    <input type="range" min="0" max="100000" id="neighbor_infections">
    <input type="number" id="neighbor_infections-value">
 </td>
 <td>
    <label for="global_infections">Global Interactions Per Million</label>
    <input type="range" min="0" max="1000" id="global_infections">
    <input type="number" id="global_infections-value">
 </td>
</tr>
<tr>
 <td>
  <label for="pop">Group Size:</label>
  <input type="range" min="0" max="1e7" id="pop">
  <input type="number" id="pop-value">
</td>
 <td>
  <label for="group_skew">Heterogenity:</label>
  <input type="range" min="0" max="10.0" id="group_skew" step=.01>
  <input type="number" id="group_skew-value">
</td>
</tr>
<tr>
 <td>
    <label for="quarantine_percentage">Quarantine Percentage:</label>
    <input type="range" min="0" max="100" id="quarantine_percentage">
    <input type="number" id="quarantine_percentage-value">
 </td>
  <td>
    <label for="quarantine_leave_percentage">Quarantine Leave Percentage:</label>
    <input type="range" min="0" max="100" id="quarantine_leave_percentage">
    <input type="number" id="quarantine_leave_percentage-value">
 </td>
   <td>
    <label for="quarantine_neighbors">Quarantine Neighbors:</label>
    <input type="checkbox" id="quarantine_neighbors-value">
 </td> 
</tr>
<tr>
 <td>
    <label for="title">Display Title:</label>
    <input type="title" id="title-value">
 </td>
 <td>
    <label for="stop_day">Transition at Day:</label>
    <input type="number" id="stop_day-value">
 </td>
</td>

<td>
  <label for="transition">Transition to:</label>
  <select name="transition_options" id="transition_options" onchange="params.transition=this.options[this.selectedIndex].value; updateLink()">
  </select>  
</td>

</tr>
<tr>
  <td>
  <button onclick="saveParams()">Save Parameters</button>
  <label for="saved_params">Restore Params:</label>
    <select name="saved_param_options" id="saved_param_options" onchange="restoreParams(this.options[this.selectedIndex].value)">
    </select>  
  </td>
</tr>
<tr>
  <td>
    <button onclick="resetSimulation()">Restart</button>
    <button onclick="resetRandom()">New Random Seed</button>
    <button onclick="startAnimation()">Start/Stop Animation</button>    
    <button onclick="downloadGIF()">Download GIF</button>   
    <td>
      <label for="animation_speed">Animation Speed (Days / s):</label>
      <input type="range" min="0" max="60" id="animation_speed">
      <input type="number" id="animation_speed-value">
    </td> 
  </td>
</tr>
<tr>
 <td>
   <a href="" id="myInput">Permalink</a>
  </td>
 <td>
   <a href="" id="myAutoplayInput">Autoplay Permalink</a>
  </td>
  </tr>
</table>

<canvas id="myCanvas" width="1000" height="600" style="border:1px solid #d3d3d3;"></canvas>


<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="whammy.js"></script>
<script>


function seeded_random(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}


ROW_WIDTH = 100
GRAPH_OFFSET = 100
GROUPS = 5000


function getNeighbors(index, num_groups) {
  var x = index % ROW_WIDTH
  var y = Math.floor(index  / ROW_WIDTH)
  var num_rows = num_groups / ROW_WIDTH
  neighbors = []
  for (var i = -1; i <= 1; i++) {
    for (var j = -1; j <= 1; j++) {
      if (i != 0 || j != 0) {
        neighbor_x = (x + i) 
        neighbor_y = (y + j)
        if (neighbor_x >= 0 && neighbor_x < ROW_WIDTH && neighbor_y >= 0 && neighbor_y < num_rows) {
          neighbors.push(neighbor_y * ROW_WIDTH + neighbor_x)
        }
      }
    } 
  }
  return neighbors
}


function drawCanvas(data, day) {
  var c = document.getElementById("myCanvas");
  var ctx = c.getContext("2d");
  var rect_height = 10
  var rect_width = 10
  ctx.clearRect(0, 0, c.width, c.height);
  ctx.fillStyle = '#FFFFFF'
  ctx.fillRect(0,0, c.width, c.height)


  infected = 0
  ever_sick = 0
  population = 0
  groups_with_infection = 0
  quarantined_groups = 0
  for (group_index in data) {
    var group = data[group_index]
    infected += AllInfected(group.infected)
    population += group.population
    ever_sick += group.ever_sick
    if (infected > 0) {
      groups_with_infection += 1
    }
    if (group.in_quarantine) {
      quarantined_groups += 1
    }
  }

  ctx.fillStyle = '#000000'
  ctx.font = '15px serif';


  ctx.fillText('State: ' + params.title, 0, 15)
  ctx.fillText('Day: ' + day, 0, 30)
  ctx.fillText('Currently Infected per Million: ' + (infected * 1e6 / population).toFixed(0), 0, 45);
  ctx.fillText('Percentage Ever Infected: ' + (ever_sick * 100 / population).toFixed(2) + '%', 0, 60)
  ctx.fillText('Percentage in quarantine: ' + (quarantined_groups * 100 / data.length).toFixed(2) + '%', 0, 75)

  for (group_index in data) {

    var x = group_index % ROW_WIDTH
    var y = Math.floor(group_index  / ROW_WIDTH)
    var group = data[group_index]
    fraction_ever_infected = Math.sqrt(group.ever_sick / group.population) * 256
    ctx.fillStyle = `rgb(
      ${fraction_ever_infected},
      ${255 - fraction_ever_infected}, 
      0)`;
    rect_left = x * rect_width
    rect_top =  y * rect_height + GRAPH_OFFSET

    ctx.fillRect(rect_left, rect_top, rect_width, rect_height);
    ctx.beginPath();
    ctx.rect(rect_left, rect_top, rect_width, rect_height);
    ctx.stroke();
    if (data[group_index].in_quarantine) {
      ctx.strokeStyle = '#000000'
      ctx.beginPath();
      ctx.moveTo(rect_left, rect_top);
      ctx.lineTo(rect_left + rect_width, rect_top + rect_height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(rect_left + rect_width, rect_top);
      ctx.lineTo(rect_left, rect_top + rect_height);
      ctx.stroke();
    }
  }
  encoder.add(c)
}


function paramOrDefault(w, param, default_val) {
  if (param == "title" || param == "quarantine_neighbors" || param == "transition") {
    return w.get(param) || default_val
  }
  let val = parseFloat(w.get(param))
  if(val == 0) {
    return 0
  }
  return val || default_val
  
}
  
function defaultParams() {
  return {
    random_seed: new Date().getTime(),
    r0: 1.0,
    group_skew: 2.0,
    neighbor_infections: 1000,
    global_infections: 10,
    pop: 1e6,
    quarantine_percentage: 1,
    quarantine_leave_percentage: .1,
    days: 100,
    infected_days: 7,
    quarantine_neighbors: false,
    title: "Initial State",
    stop_day: 200,
    animation_speed: 5,
    transition: ""
  } 
}

function getParams() {
  let w = new URLSearchParams(window.location.search)

  default_params = defaultParams()
  params = {}
  for (let [key, value] of Object.entries(default_params)) {
     params[key] = paramOrDefault(w, key, value)
  } 
  return params
}

function resetRand() {
  seededRandom = seeded_random(params.random_seed)
}
original_params = null
params = getParams()
saved_params = JSON.parse(new URLSearchParams(window.location.search).get("saved_params")) || {}
autoplay = new URLSearchParams(window.location.search).get("autoplay") || false

resetRand()
groups = []
day = 1

function makeWindowParams(autoplay) {
  var original_params = defaultParams()
  parts = []
  for (let [key, value] of Object.entries(params)) {
     if (value != original_params[key]) {
      parts.push(key + "=" + value)
     }
  }
  if (autoplay) {
    parts.push("autoplay=1")
  }
  parts.push("saved_params" + "=" + JSON.stringify(saved_params)) 
  return parts.join("&")  
}

function initialInfected(num_infected, infected_days) {
  infection = []
  for (var i = 0; i < infected_days; i++) {
    infection.push(0)
  }
  infection[0] = num_infected
  return infection
}

function initialState() {
   groups = []
   total_r0 = 0.0
   expected_total = GROUPS
   initial_infected_groups = {}
   for (i=0; i < 10; i++) {
    initial_infected_groups[getRandomInt(0, GROUPS)] = true
   }

   for(i=0 ; i < GROUPS; i++) {
    group_r0 =  Math.pow(seededRandom(), params.group_skew)
    total_r0 += group_r0
    infected = 0
    if (i in initial_infected_groups) {
      infected = 100
    }
    groups.push({
      population: params.pop,
      infected: initialInfected(infected, params.infected_days),
      neighbors: {},
      ever_sick: infected,
      r0: group_r0,
      in_quarantine: false
    })}

    for (i=0; i < GROUPS; i++) {
      neighbors = getNeighbors(i, GROUPS)
      for (neighbor_index in neighbors)  {
        groups[i].neighbors[neighbors[neighbor_index]] = true
      }
    }

    for (group_index in groups) {
      r0 = groups[group_index].r0
      groups[group_index].r0 = r0 * (expected_total / total_r0)
    }

   return groups
}

function poisson(mean) {
  var k = 0
  while (mean > 2048) {
    k += mean / 2
    mean /= 2
  }
  var L = -mean;
  var p = 0.0;
  
  do {
      k++;
      p += Math.log(seededRandom());
  } while (p > L);

  return k - 1;
}

function expectedNewInfections(state, new_infections) {
  if(state.population == 0 || new_infections == 0) {
    return 0;
  }
  actual_infections = poisson(new_infections)

  prob_single_not = 1 - (1 / state.population)
  prob_total_not = Math.pow(prob_single_not, actual_infections)
  prob_selected = 1 - prob_total_not
  return Math.round((state.population - state.ever_sick) * prob_selected) 
}

function AddInfections(existing_infections, new_infections) {
  added_infections = []
  added_infections.push(new_infections)
  for (var i = 0; i < existing_infections.length - 1; i++) {
    added_infections.push(existing_infections[i])
  }
  return added_infections
}

function AllInfected(group_infections) {
  total_infected = 0
  for (var i in group_infections) {
    total_infected += group_infections[i]
  }
  return total_infected
}

function inQuarantine(group) {
  percentage_infected = AllInfected(group.infected) * 100 / group.population
  return percentage_infected >= params.quarantine_percentage || (group.in_quarantine && percentage_infected >= params.quarantine_leave_percentage)
}

function advanceState(current_groups, day) {
   new_groups = []
   infections_by_group = []
   global_infections = 0
   in_quarantine = []
   num_not_in_quarantine = 0

   for (i = 0; i < current_groups.length; i++) {
    in_quarantine.push(false)
    infections_by_group.push(0)
   }

   for (i = 0; i < current_groups.length; i++) {
    var current_group = current_groups[i]
    group_in_quarantine = inQuarantine(current_group)
    if (group_in_quarantine) {
      in_quarantine[i] = true
      if (params.quarantine_neighbors) {
        for (var neighbor in current_group.neighbors) {
          in_quarantine[neighbor] = true
        }
      }
    }
   }

   for (i = 0; i < current_groups.length; i++) {
    current_infected = AllInfected(current_groups[i].infected)
    if (in_quarantine[i]) {
      fraction_global = 0
      fraction_neighbor = 0
    } else {
      fraction_global = params.global_infections / 1e6
      fraction_neighbor = params.neighbor_infections / 1e6
      num_not_in_quarantine += 1
    }
    fraction_local = 1 - (fraction_neighbor + fraction_global)
    new_infections = current_infected * current_groups[i].r0 * params.r0 / params.infected_days
    global_infections += new_infections * fraction_global
    infections_by_group[i] += new_infections * fraction_local
    non_quarantine_neighbors = []
    for (neighbor in current_groups[i].neighbors) {
      if (!in_quarantine[neighbor]) {
        non_quarantine_neighbors.push(neighbor)
      }
    }
    for (neighbor_index in non_quarantine_neighbors) {
      infections_by_group[non_quarantine_neighbors[neighbor_index]] += (new_infections * fraction_neighbor) / non_quarantine_neighbors.length
    }
   }

   for (i = 0; i < current_groups.length; i++) {
      var group = current_groups[i]
      group_global_infections = 0
      if (!in_quarantine[i]) {
        group_global_infections = global_infections / (num_not_in_quarantine)
      }
      actual_infections = expectedNewInfections(group, group_global_infections + infections_by_group[i])
      new_groups.push({
        population: group.population,
        neighbors: group.neighbors,
        infected: AddInfections(group.infected, actual_infections),
        ever_sick: group.ever_sick + actual_infections,
        r0: group.r0,
        in_quarantine: in_quarantine[i]
      })
   }
   return new_groups
}

function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(seededRandom() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive
}


function getTotalParams(current_groups, day) {
  total_infected = 0
  total_population = 0
  total_sick = 0
  total_lockdown = 0
  for (i = 0; i < current_groups.length; i++) {
    total_infected += current_groups[i].ever_sick
    total_population += current_groups[i].population
    total_sick += current_groups[i].infected[0]
    total_lockdown += current_groups[i].in_quarantine ? 1 : 0
  }
  return {
    day: day,
    ever_sick: total_infected,
    population: total_population,
    infected: total_sick,
    total_lockdown: total_lockdown,
  }
}

timeout_id = null

var encoder = new Whammy.Video(15); 

function handleDataAvailable(event) {
  if (event.data.size > 0) {
    recordedChunks.push(event.data);
  }
}


function stopAnimation() {
  if (timeout_id != null) {
    window.clearInterval(timeout_id)
    timeout_id = null    
  }
}

function startAnimation() {
  if (timeout_id == null) {
    timeout_id = window.setInterval(advanceDayInternal, 1000 / params.animation_speed)
  } else {
    stopAnimation()
  }
}

function resetSimulation() {
  resetRand()
  stopAnimation()
  if (original_params != null) {
    params = original_params
    initializeParams()
    original_params = null
  }
  encoder = new Whammy.Video(params.animation_speed)
  groups = initialState()
  day = 1
  drawCanvas(groups, day)
}

function advanceDay() {
  stopAnimation()
  advanceDayInternal()
}

function advanceDayInternal() {
  if (day == 1) {
    resetRand()
    groups = initialState()
  }
  day += 1
  groups = advanceState(groups, day)
  drawCanvas(groups, day)
  if (day >= params.stop_day) {
    if (params.transition == '') {
      stopAnimation()
    } else {
      if (original_params == null) {
        original_params = params
      }
      restoreParams(params.transition)
    }
  }
}

function resetRandom() {
  params.random_seed = new Date().getTime()
  resetRand()
}

function downloadGIF() {
  stopAnimation()
  encoder.compile(false, function(output){
    url = URL.createObjectURL(output)
    window.open(url)}
  ) 
}

function saveParams() {
  new_params = {}
  for (let [key, value] of Object.entries(params)) {
    new_params[key] = value
  }
  saved_params[params.title] = new_params
  initializeParams()
}

function restoreParams(title) {
  old_seed = params["random_seed"]
  old_speed = params["animation_speed"]
  old_group_size = params["pop"]
  old_group_skew = params["group_skew"]
  if (title === "") {
    return
  }
  params = saved_params[title]
  params["random_seed"] = old_seed
  params["animation_speed"] = old_speed
  params["pop"] = old_group_size
  params["group_skew"] = old_group_skew
  initializeParams()
}

function clearSavedParams() {
  saved_params = {}
  initializeParams()
}

function updateLink() {
  var copyText = document.getElementById("myInput");
  copyText.href =  window.location.href.split('?')[0] + "?" + makeWindowParams(false)
  var autoplayCopyText = document.getElementById("myAutoplayInput");
  autoplayCopyText.href =  window.location.href.split('?')[0] + "?" + makeWindowParams(true)
   
}

function updateAttribute(attribute, value, update_graph=true) {
  // adjust the text on the range slider
  d3.select("#" + attribute + "-value").text(value);
  d3.select("#" + attribute + "-value").property("value", value);
  d3.select("#" + attribute).property("value", value);
  updateLink()
}


function initializeParams() {
  param_select_str = '<option hidden value=""></option>'
  transition_select_str = '<option value="">Stop</option>'
  param_index = 1
  found_param_index = 0
  found_transition_index = 0
  for (key in saved_params) {
    param_select_str += `<option value="${key}">${key}</option>`
    transition_select_str += `<option value="${key}">${key}</option>`
    if (key == params.title) {
      found_param_index = param_index
    }
    if (key == params.transition) {
      found_transition_index = param_index
    }
    param_index++
  }
  document.getElementById("saved_param_options").innerHTML = param_select_str;
  document.getElementById("saved_param_options").options.selectedIndex = found_param_index

  document.getElementById("transition_options").innerHTML = transition_select_str
  document.getElementById("transition_options").options.selectedIndex = found_transition_index

  for (let [key, value] of Object.entries(params)) {
    if (key == 'transition') {
      continue;
    }
    d3.select("#" + key).on("input", function() {
      params[key] = +this.value;
      updateAttribute(key, +this.value);
    });

    d3.select("#" + key + "-value").on("input", function() {
      params[key] = +this.value;
      updateAttribute(key, +this.value);
    });
    updateAttribute(key, value, false)
  }


  d3.select("#" +  "quarantine_neighbors-value").on("input", function() {
    params["quarantine_neighbors"] = +this.checked;
    updateAttribute("quarantine_neighbors", +this.value);
    d3.select("#quarantine_neighbors-value").property('checked', +this.checked);
  });
  d3.select("#quarantine_neighbors-value").property('checked', params["quarantine_neighbors"]);

  d3.select("#" +  "title-value").on("input", function() {
    params["title"] = this.value;
    updateAttribute("title", this.value);
  });  
  d3.select('#title-value').property('value', this.value)

}
function initializeGraph() {
  initializeParams()
  resetSimulation()
}
initializeGraph()
if (autoplay) {
  startAnimation()
}
</script>
